/*
- first 8 bits represent the Deck length (number of remaining cards)
- last 52 bits represent the Deck itself (set of card enums)
- the remaining 4 bits in between is the deck id,..
  ..which allows us to access the associated uint8_t[52]..
  ..for drawing cards
*/
using Deck = uint64_t;

/*
the functions are the following:

(ability to implicitly cast from Deck to Cards)

- draw(Deck*) -- draw a card from the deck

- hasCard(Cards, Card) -- check whether the deck contains the card
- hasCards(Cards, Cards) -- ...

- inter(Cards, Cards) -- returns the Cards contained in both decks
- union(Cards, Cards) -- returns the Cards contained in either decks
- diff(Cards a, Cards b) -- returns the Cards that are in A exclusively (A - B)
- symdiff(Cards a, Cards b) -- returns the Cards contained in either decks but not both

- remaining(Cards) -- returns the remaining cards in the deck
  -> returns itself (identity function)
- missing(Cards) -- returns the set of missing cards (complement of cards)

selectors:
- cards(Deck) -- returns the set of cards
- len(Deck) -- returns the number of remaining cards in the deck

*/



Faire des macros au lieu de faire des fonctions ?? (BANGER)


Dans ce cas pratique il est inutile de passer des Cards par const ref (const int64_t*)..
..car dans les deux cas ça copie 64 bits de données (une adresse c'est 8 bytes sur..
..une architecture 64 bits)

Comme la plupart des fonctions vont retournées un uint64_t,..
..on peut utiliser les opérateurs && et || à la place des if/unless.
e.g.: cards(deck) && <draw>
  -> ca retourne 0 si le deck est vide (on peut pas draw quoi)


TODO: faire la partie "Deck" (avec la fonction draw()..)
